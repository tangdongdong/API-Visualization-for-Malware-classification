package main;

import jxl.Sheet;
import jxl.Workbook;
import jxl.read.biff.BiffException;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import javax.imageio.ImageIO;

import java.awt.image.BufferedImage;
import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

public class MalwareVisualization {
	// In experiment, we divided the run time of the program into N equal
	// parts, where N = 16
	public static final int NUM_OF_UNIT_TIME = 16;
	// In experiment, we divided the API into 16 categoriesï¼Œthere are:High
	// Risk,Networking,Register,Service,File,etc
	public static final int NUM_OF_API_CATEGORY = 16;
	// In experiment, we divided the malicious levels into 11 levels
	public static final int MALICIOUS_LEVEL = 11;

	/**
	 * convert json report file to JSONObject
	 */
	public JSONObject getJsonObject(String jsonFilePath) {
		StringBuilder stringBuilder = new StringBuilder();
		BufferedReader bufferedReader = null;
		JSONObject jsonObject = null;
		try {
			bufferedReader = new BufferedReader(new FileReader(new File(
					jsonFilePath)));
			String str = null;
			while ((str = bufferedReader.readLine()) != null) {
				stringBuilder.append(str);
			}
			jsonObject = new JSONObject(stringBuilder.toString());
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (JSONException e) {
			e.printStackTrace();
		} finally {
			if (bufferedReader != null) {
				try {
					bufferedReader.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
		return jsonObject;
	}

	/**
	 * Split API Sequence to k fragment, where k = NUM_OF_UNIT_TIME
	 */
	public Map<Integer, ArrayList<String>> equalDivide(JSONObject monitorReport) {
		Map<Integer, ArrayList<String>> fragment = new HashMap<Integer, ArrayList<String>>();
		try {
			// Step 1: get the start_time and end_time, then calculate the
			// "unit time", where unit time = (end_time - start_time) / k.
			double startTime = monitorReport.getJSONObject("info").getDouble(
					"started");
			double endTime = monitorReport.getJSONObject("info").getDouble(
					"ended");
			double unit_time = (endTime - startTime) / NUM_OF_UNIT_TIME;

			// Step 2: Split API call Sequence to k fragment, where k = NUM_OF_UNIT_TIME
			JSONArray processes = monitorReport.getJSONObject("behavior")
					.getJSONArray("processes");
			// init fragment object
			for (int i = 1; i <= NUM_OF_UNIT_TIME; i++) {
				fragment.put(i, new ArrayList<String>());
			}
			double[] ceiling = new double[NUM_OF_UNIT_TIME];
			for (int i = 1; i <= NUM_OF_UNIT_TIME; i++) {
				ceiling[i - 1] = startTime + i * unit_time;
			}

			double callTimeTemp;
			String APINameTemp = "";
			JSONObject temp = new JSONObject();
			for (int i = 0; i < processes.length(); i++) {
				JSONArray calls = processes.getJSONObject(i).getJSONArray(
						"calls");
				for (int k = 0; k < calls.length(); k++) {
					temp = (JSONObject) calls.get(k);
					APINameTemp = temp.getString("api");
					callTimeTemp = temp.getDouble("time");
					for (int j = 0; j < NUM_OF_UNIT_TIME; j++) {
						if (callTimeTemp > ceiling[j])
							continue;
						else {
							fragment.get(j + 1).add(APINameTemp);
							break;
						}
					}
				}
			}
		} catch (JSONException e) {
			e.printStackTrace();
		}
		return fragment;
	}

	/**
	 * Get API list for each API category
	 */
	public Map<Integer, HashSet<String>> getAPIList() {
		Map<Integer, HashSet<String>> APIMap = new HashMap<Integer, HashSet<String>>();
		try {
			/*
			 * Please replace the relative address with an Absolute Address
			 * here, to ensure proper operation of the program
			 */
			File file = new File("../../color_mapping_rule/API-Category.xls");
			Workbook workbook = Workbook.getWorkbook(file);
			Sheet sheet = workbook.getSheet(0);
			HashSet<String> set = null;
			for (int column = 0; column < NUM_OF_UNIT_TIME - 1; column++) {
				set = new HashSet<String>();
				for (int row = 1; row < sheet.getColumn(column).length; row++) {
					set.add(sheet.getCell(column, row).getContents().trim());
				}
				set.remove("");
				APIMap.put(column + 1, set);
			}
			workbook.close();
		} catch (BiffException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return APIMap;
	}

	/**
	 * get the matrix that store the occur times for each API category on each
	 * "unit time"
	 */
	public int[][] getOccurCounterMatrix(
			Map<Integer, ArrayList<String>> fragments,
			Map<Integer, HashSet<String>> APIList) {
		int[][] occurMatrix = new int[NUM_OF_UNIT_TIME][NUM_OF_API_CATEGORY];

		for (int i = 1; i <= fragments.size(); i++) {
			ArrayList<String> fragment = fragments.get(i);
			boolean isOther;
			for (String API : fragment) {
				isOther = true;
				for (int j = 1; j <= APIList.size(); j++) {
					if (APIList.get(j).contains(API)) {
						occurMatrix[j - 1][i - 1]++;
						isOther = false;
					}
				}
				if (isOther)
					occurMatrix[NUM_OF_API_CATEGORY - 1][i - 1]++;
			}
		}
		return occurMatrix;
	}

	/**
	 * get the color mapping rules
	 */
	public int[][] getColorMappingRules() {
		int[][] colorMappingRules = new int[NUM_OF_API_CATEGORY][MALICIOUS_LEVEL];
		try {
			/*
			 * Please replace the relative address with an Absolute Address
			 * here, to ensure proper operation of the program
			 */
			File file = new File("../../color_mapping_rule/Color-Map-Rules.xls");
			Workbook workbook = Workbook.getWorkbook(file);
			Sheet sheet = workbook.getSheet(0);
			for (int row = 1; row <= NUM_OF_API_CATEGORY; row++) {
				for (int column = 1; column <= MALICIOUS_LEVEL; column++)
					colorMappingRules[row - 1][column - 1] = Integer.valueOf(
							sheet.getCell(column, row).getContents()
									.substring(1), 16);
			}
		} catch (BiffException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return colorMappingRules;
	}

	/**
	 * Get the matrix that store the pixel value of each pixel in the feature
	 * image
	 */
	public int[][] colorValueMatrix(int[][] occurCounterMatrix,
			int[][] colorMappingRules) {
		int[][] colorValueMatrix = new int[NUM_OF_API_CATEGORY][NUM_OF_UNIT_TIME];

		for (int i = 0; i < occurCounterMatrix.length; i++) {
			for (int j = 0; j < occurCounterMatrix[i].length; j++) {
				if (occurCounterMatrix[i][j] > 200) {
					colorValueMatrix[i][j] = colorMappingRules[i][MALICIOUS_LEVEL - 1];
				} else if (occurCounterMatrix[i][j] > 100) {
					colorValueMatrix[i][j] = colorMappingRules[i][MALICIOUS_LEVEL - 2];
				} else if (occurCounterMatrix[i][j] > 42) {
					colorValueMatrix[i][j] = colorMappingRules[i][MALICIOUS_LEVEL - 3];
				} else if (occurCounterMatrix[i][j] > 33) {
					colorValueMatrix[i][j] = colorMappingRules[i][MALICIOUS_LEVEL - 4];
				} else if (occurCounterMatrix[i][j] > 25) {
					colorValueMatrix[i][j] = colorMappingRules[i][MALICIOUS_LEVEL - 5];
				} else if (occurCounterMatrix[i][j] > 18) {
					colorValueMatrix[i][j] = colorMappingRules[i][MALICIOUS_LEVEL - 6];
				} else if (occurCounterMatrix[i][j] > 12) {
					colorValueMatrix[i][j] = colorMappingRules[i][MALICIOUS_LEVEL - 7];
				} else if (occurCounterMatrix[i][j] > 7) {
					colorValueMatrix[i][j] = colorMappingRules[i][MALICIOUS_LEVEL - 8];
				} else if (occurCounterMatrix[i][j] > 3) {
					colorValueMatrix[i][j] = colorMappingRules[i][MALICIOUS_LEVEL - 9];
				} else if (occurCounterMatrix[i][j] > 0) {
					colorValueMatrix[i][j] = colorMappingRules[i][MALICIOUS_LEVEL - 10];
				} else {
					colorValueMatrix[i][j] = colorMappingRules[i][MALICIOUS_LEVEL - 11];
				}
			}
		}
		return colorValueMatrix;
	}

	/** convert the colorValueMatrix to an image */
	public void generateImage(int[][] colorValueMatrix, String desPath) {
		BufferedImage bufferedImage = new BufferedImage(NUM_OF_API_CATEGORY,
				NUM_OF_UNIT_TIME, BufferedImage.TYPE_3BYTE_BGR);
		File des = new File(desPath);
		try {
			for (int i = 0; i < colorValueMatrix.length; i++) {
				for (int j = 0; j < colorValueMatrix[i].length; j++) {
					bufferedImage.setRGB(j, i, colorValueMatrix[i][j]);
				}
			}
			ImageIO.write(bufferedImage, "jpg", des);
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			bufferedImage.flush();
		}
	}

}
